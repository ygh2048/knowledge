# 一些面试问题

## volitate,const，static和extern

### volatite
- 禁止优化，强制内存访问
- 在程序外修改变量
- 不保证线程安全

### const
- 定义可修改的常量或限制修改
- 定义常量或不可修改的变量/函数参数/成员函数

### static
- 控制存储期或作用域  
- 类成员
- 静态变量

### extern
- 访问其他文件中的全局变量
- 在头文件中声明全局变量
- C++中调用C函数
- 定义可跨文件访问的const
- extern 不能用于局部变量


### 补充
volatite const 修饰：
用于只读硬件寄存器，限制程序对寄存器的更改，但是其内容可能会被硬件改变。
同于：
- 只读硬件寄存器，如状态寄存器，配置寄存器
- 多线程/中断共享的只读数据。如全局配置
- 固件/ROM数据，可能被外部更新


## 引用和指针的区别

## 宏定义和内联函数
## 堆和栈的对比
### 栈
- 编译器自动分配和释放
- 函数/程序结束自动释放
- 空间较小，依赖与系统
- 分配速度较快，无内存碎片
- 向低地址增长
- 每个线程独占栈

### 堆
- 程序员手动分配（malloc/free）
- free后才释放
- 空间较大
- 分配速度慢，可能产生内存碎片
- 向着高地址增长
- 全局共享，需要同步机制

## C语言编译过程

## 数组和指针

## 结构体的大小，地址关系

## 什么是内存泄漏


## NULL的使用

## 对比一下队列和栈

## 函数调用的过程
函数A调用函数B
1. 暂停A的执行
2. 保存A的当前状态到内存中-调用栈（压入栈顶）
3. 为B分配栈空间
4. CPU控制权转移到B
5. B执行完毕（return）
6. 销毁B的栈帧
7.  从栈中恢复A的状态
8.  调回A中当初调用B之后的位置开始执行

# knowledge
## 引用和指针
### 引用
引用是已存在变量的别名
引用本身不占用额外的存储空间，它只是绑定在目标对象身上；
`int& ref = var;ref = 10;等价于var = 10;`
### 指针
本质是一个变量，存储了另一个变量或对象的内存地址

`int * ptr; ptr = &var;int x = *ptr;`
## 详解函数
程序运行中，函数主要存在两个内存区域：
- 代码段
  > 位于内存中的只读区域，是编译后的机器指令
  > 程序启动后会加载到固定内存地址，所有函数共享同一代码段，大小在编译时就确定，运行时不变
- 栈
  > 运行时动态分配的内存区域,是函数调用的活动记录，（栈帧）
  > 每个函数调用创建单独的栈帧，存储参数，局部变量，返回地址等等
  > 后进先出 

### 调用执行过程
1. 调用前，参数压栈，返回地址（下一条指令地址）压栈
2. 调用时，创建栈帧，保存当前基址寄存器，设置新基址，局部变量分配
3. 函数返回，返回值准备，栈帧销毁，返回调用点



## 强制类型转换

- 许多情况下C会自动进行隐式转换，不需要显式强制转换
- 将浮点数转换为整数时会丢弃小数部分
- 将较大类型转换为较小类型可能导致数据截断

## 不同指针的区别
### 整型指针和字符指针的区别

在C语言中，整型指针(`int*`)和字符指针(`char*`)虽然都是指针类型，但在多个方面有重要区别：

#### 1. 指向的数据类型不同

- **整型指针(int*)**：指向整型数据(`int`类型)
- **字符指针(char*)**：指向字符数据(`char`类型)

#### 2. 解引用时的行为不同

```c
int num = 0x12345678;
int *int_ptr = &num;
char *char_ptr = (char *)&num;

printf("%x\n", *int_ptr);  // 输出整个int值: 0x12345678
printf("%x\n", *char_ptr); // 只输出第一个字节(依赖字节序)
```

#### 3. 指针算术运算的步长不同

- `int*`指针加1时，地址增加`sizeof(int)`(通常4字节)
- `char*`指针加1时，地址增加`sizeof(char)`(总是1字节)

```c
int arr[3] = {1, 2, 3};
int *int_p = arr;
char *char_p = (char *)arr;

int_p++;  // 地址增加4字节(指向arr[1])
char_p++; // 地址增加1字节(指向第二个字节)
```

#### 4. 内存访问粒度不同

- `int*`通常按4字节(32位系统)或8字节(64位系统)访问内存
- `char*`按单字节访问内存

#### 5. 常见用途不同

- **int***：
  - 用于操作整型数组
  - 数值计算
  - 作为通用指针(在某些情况下)

- **char***：
  - 字符串处理
  - 内存操作(因为可以逐字节访问)
  - 二进制数据处理

#### 6. 字节序影响

字符指针常用于检测系统字节序：

```c
int num = 0x12345678;
char *p = (char *)#

if (*p == 0x78) {
    printf("小端序\n");
} else {
    printf("大端序\n");
}
```

#### 7. 对齐要求不同

- `int*`通常有更严格的内存对齐要求
- `char*`可以指向任何内存地址

#### 重要注意事项

1. **类型转换需谨慎**：整型指针和字符指针间的转换可能违反严格别名规则
2. **指针运算**：不同类型的指针运算结果完全不同
3. **可移植性**：依赖于系统的字节序和整数大小

理解这些区别对于正确操作内存、避免未定义行为非常重要。



# code

## 递归的写法

### 条件
两个基本条件：
- 存在递归终止条件，当满足这个条件的时候，递归不在继续，避免无限递归的栈溢出
- 每次递归都更接近终止条件

### 编写递归函数三要素
 
- 确定函数返回值和传入参数
- 确定递归终止条件
- 确定单层递归的逻辑


## 字符串函数及其用法
**头文件**：`#include <cstring>`  
**注意**：操作以`\0`结尾的`char`数组，需手动管理内存

| 函数        | 用法示例                          | 说明                                |
|-------------|-----------------------------------|-------------------------------------|
| `strlen`    | `int len = strlen(str);`          | 获取字符串长度                      |
| `strcpy`    | `strcpy(dest, src);`              | 复制字符串（需确保`dest`足够大）    |
| `strncpy`   | `strncpy(dest, src, n);`          | 复制最多`n`个字符                   |
| `strcat`    | `strcat(dest, src);`              | 字符串拼接（需确保`dest`足够大）    |
| `strncat`   | `strncat(dest, src, n);`          | 拼接最多`n`个字符                   |
| `strcmp`    | `if (strcmp(s1, s2) == 0) {...}`  | 字符串比较（返回0表示相等）         |
| `strncmp`   | `strncmp(s1, s2, n);`             | 比较前`n`个字符                     |
| `strchr`    | `char* p = strchr(s, 'a');`       | 查找字符首次出现位置                |
| `strrchr`   | `char* p = strrchr(s, 'a');`      | 查找字符最后出现位置                |
| `strstr`    | `char* p = strstr(s, "sub");`     | 查找子串位置                        |
| `strtok`    | `char* tok = strtok(s, ",");`     | 分割字符串（非线程安全）            |

---
# 跳转链接
[点这里跳转list](../list.md)