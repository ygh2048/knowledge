# 一些面试问题

## volitate,const，static和extern

### volatite
- 禁止优化，强制内存访问
- 在程序外修改变量
- 不保证线程安全

### const
- 定义可修改的常量或限制修改
- 定义常量或不可修改的变量/函数参数/成员函数

### static
- 控制存储期或作用域  
- 类成员
- 静态变量

### extern
- 访问其他文件中的全局变量
- 在头文件中声明全局变量
- C++中调用C函数
- 定义可跨文件访问的const
- extern 不能用于局部变量



### 补充
volatite const 修饰：
用于只读硬件寄存器，限制程序对寄存器的更改，但是其内容可能会被硬件改变。
同于：
- 只读硬件寄存器，如状态寄存器，配置寄存器
- 多线程/中断共享的只读数据。如全局配置
- 固件/ROM数据，可能被外部更新

## 静态函数/变量
static修饰    
### C语言
- 局部静态变量
  - 生命周期为整个程序运行过程
  - 只在声明其的函数中可见
  - 在函数调用后不会重新被初始化
- 全局静态变量
  - 仅限与定义它的源文件内部可见
  - 用于避免命名冲突
  - 正常全局变量可以使用extern访问，静态全局变量使用extern也无法访问

- 静态函数
  - 仅限与定义它的源文件可见
  - 避免命名冲突

### CPP
- 类的静态成员函数
  - 不依赖类的实例，可以直接通过类名调用
  - 只能访问类的静态成员变量
  - 没有this指针
- 类的静态成员变量
  - 被类的所用对象共享
  - 必须在类外单独定义和初始化
  - 不依赖任何类对象而存在

## 引用和指针的区别
- 引用是一个对象的别名
  - 一旦初始化就不能改变绑定的对象
  - 不能为空
  - 没有多级引用
  - 安全
- 指针是一个存储对象地址的变量
  - 可以改变存储的地址
  - 可以为空
  - 存在多级指针
  - 不安全

## 宏定义和内联函数
- 宏定义
  - 预处理器指令，在编译前文本替换
  - 没有类型检查
  - 用于
    - 定义常量
    - 简单的代码扩展
    - 条件编译
- 内联函数
  - 编译器指令，是函数
  - 有类型检查
  - 会在函数调用处直接嵌入函数体，这个取决于编译器是否决定内联
  


## 宏定义和typedef
- 宏定义可以替换任何文本
- typedef是专门为类型创建别名
  - 与struct union enum结合
  - 声明指针比较直观自然



## 堆和栈的对比
### 栈
- 编译器自动分配和释放
- 函数/程序结束自动释放
- 空间较小，依赖与系统
- 分配速度较快，无内存碎片
- 向低地址增长
- 每个线程独占栈

### 堆
- 程序员手动分配（malloc/free）
- free后才释放
- 空间较大
- 分配速度慢，可能产生内存碎片
- 向着高地址增长
- 全局共享，需要同步机制

## C语言编译过程

## 数组和指针

## 结构体的大小，地址关系

## 什么是内存泄漏


## NULL / nullptr的使用

## 对比一下队列和栈

## 函数调用的过程
函数A调用函数B
1. 暂停A的执行
2. 保存A的当前状态到内存中-调用栈（压入栈顶）
3. 为B分配栈空间
4. CPU控制权转移到B
5. B执行完毕（return）
6. 销毁B的栈帧
7.  从栈中恢复A的状态
8.  调回A中当初调用B之后的位置开始执行

# knowledge
## 引用和指针
### 引用
引用是已存在变量的别名
引用本身不占用额外的存储空间，它只是绑定在目标对象身上；
`int& ref = var;ref = 10;等价于var = 10;`
### 指针
本质是一个变量，存储了另一个变量或对象的内存地址

`int * ptr; ptr = &var;int x = *ptr;`
## 详解函数
程序运行中，函数主要存在两个内存区域：
- 代码段
  > 位于内存中的只读区域，是编译后的机器指令
  > 程序启动后会加载到固定内存地址，所有函数共享同一代码段，大小在编译时就确定，运行时不变
- 栈
  > 运行时动态分配的内存区域,是函数调用的活动记录，（栈帧）
  > 每个函数调用创建单独的栈帧，存储参数，局部变量，返回地址等等
  > 后进先出 

### 调用执行过程
1. 调用前，参数压栈，返回地址（下一条指令地址）压栈
2. 调用时，创建栈帧，保存当前基址寄存器，设置新基址，局部变量分配
3. 函数返回，返回值准备，栈帧销毁，返回调用点



## 强制类型转换

- 许多情况下C会自动进行隐式转换，不需要显式强制转换
- 将浮点数转换为整数时会丢弃小数部分
- 将较大类型转换为较小类型可能导致数据截断

## 不同指针的区别
### 整型指针和字符指针的区别

在C语言中，整型指针(`int*`)和字符指针(`char*`)虽然都是指针类型，但在多个方面有重要区别：

#### 1. 指向的数据类型不同

- **整型指针(int*)**：指向整型数据(`int`类型)
- **字符指针(char*)**：指向字符数据(`char`类型)

#### 2. 解引用时的行为不同

```c
int num = 0x12345678;
int *int_ptr = &num;
char *char_ptr = (char *)&num;

printf("%x\n", *int_ptr);  // 输出整个int值: 0x12345678
printf("%x\n", *char_ptr); // 只输出第一个字节(依赖字节序)
```

#### 3. 指针算术运算的步长不同

- `int*`指针加1时，地址增加`sizeof(int)`(通常4字节)
- `char*`指针加1时，地址增加`sizeof(char)`(总是1字节)

```c
int arr[3] = {1, 2, 3};
int *int_p = arr;
char *char_p = (char *)arr;

int_p++;  // 地址增加4字节(指向arr[1])
char_p++; // 地址增加1字节(指向第二个字节)
```

#### 4. 内存访问粒度不同

- `int*`通常按4字节(32位系统)或8字节(64位系统)访问内存
- `char*`按单字节访问内存

#### 5. 常见用途不同

- **int***：
  - 用于操作整型数组
  - 数值计算
  - 作为通用指针(在某些情况下)

- **char***：
  - 字符串处理
  - 内存操作(因为可以逐字节访问)
  - 二进制数据处理

#### 6. 字节序影响

字符指针常用于检测系统字节序：

```c
int num = 0x12345678;
char *p = (char *)#

if (*p == 0x78) {
    printf("小端序\n");
} else {
    printf("大端序\n");
}
```

#### 7. 对齐要求不同

- `int*`通常有更严格的内存对齐要求
- `char*`可以指向任何内存地址

#### 重要注意事项

1. **类型转换需谨慎**：整型指针和字符指针间的转换可能违反严格别名规则
2. **指针运算**：不同类型的指针运算结果完全不同
3. **可移植性**：依赖于系统的字节序和整数大小

理解这些区别对于正确操作内存、避免未定义行为非常重要。

## 结构体的地址大小与内存对齐
### 原因
CPU以子长为单位访问内存，而不是以字节为单位访问。   

### 对齐规则

- 偏移规则 结构体成员中的每个成员的起始地址，必须是该成员自身大小与编译器默认对齐模数两者中较小者的整数倍 
- 大小规则 整个结构体的总大小，必须是所有成员中最大对齐模数的整数倍，如果不是，需要在结构体末尾填充字节
- 嵌套规则 如果结构体包含另外一个结构体，则该成员的对齐模数是其内部最大成员的大小

### 常见类型大小


char: 一个字节    
int: 四个字节 
long:四个/八个字节
void*:四个/八个字节 
float:四个字节  
double:八个字节 

### 优化技巧
合理安排结构体成员顺序，从小到大排列或者从大到小排列，可以减少填充字节  



## 数组与指针的区别
指针会有一个专门的地址来存放指针的值，而指针的值又是指针指向元素的地址。    


### 数组名，和数组值
- 数组名  ： 是一个编译器符号，运行时不占用存储空间来存储一个地址值，会直接被编译器解析为数组首元素的地址


## 浅复制和深复制对比



# code

## 递归的写法

### 条件
两个基本条件：
- 存在递归终止条件，当满足这个条件的时候，递归不在继续，避免无限递归的栈溢出
- 每次递归都更接近终止条件

### 编写递归函数三要素
 
- 确定函数返回值和传入参数
- 确定递归终止条件
- 确定单层递归的逻辑


## 字符串函数及其用法
**头文件**：`#include <cstring>`  
**注意**：操作以`\0`结尾的`char`数组，需手动管理内存

| 函数        | 用法示例                          | 说明                                |
|-------------|-----------------------------------|-------------------------------------|
| `strlen`    | `int len = strlen(str);`          | 获取字符串长度                      |
| `strcpy`    | `strcpy(dest, src);`              | 复制字符串（需确保`dest`足够大）    |
| `strncpy`   | `strncpy(dest, src, n);`          | 复制最多`n`个字符                   |
| `strcat`    | `strcat(dest, src);`              | 字符串拼接（需确保`dest`足够大）    |
| `strncat`   | `strncat(dest, src, n);`          | 拼接最多`n`个字符                   |
| `strcmp`    | `if (strcmp(s1, s2) == 0) {...}`  | 字符串比较（返回0表示相等）         |
| `strncmp`   | `strncmp(s1, s2, n);`             | 比较前`n`个字符                     |
| `strchr`    | `char* p = strchr(s, 'a');`       | 查找字符首次出现位置                |
| `strrchr`   | `char* p = strrchr(s, 'a');`      | 查找字符最后出现位置                |
| `strstr`    | `char* p = strstr(s, "sub");`     | 查找子串位置                        |
| `strtok`    | `char* tok = strtok(s, ",");`     | 分割字符串（非线程安全）            |




---
# 跳转链接
[点这里跳转list](../list.md)