# 一些面试问题

## volitate,const，static和extern

### volatite
- 禁止优化，强制内存访问
- 在程序外修改变量
- 不保证线程安全

### const
- 定义可修改的常量或限制修改
- 定义常量或不可修改的变量/函数参数/成员函数

### static
- 控制存储期或作用域  
- 类成员

### extern
- 访问其他文件中的全局变量
- 在头文件中声明全局变量
- C++中调用C函数
- 定义可跨文件访问的const
- extern 不能用于局部变量


### 补充
volatite const 修饰：
用于只读硬件寄存器，限制程序对寄存器的更改，但是其内容可能会被硬件改变。
同于：
- 只读硬件寄存器，如状态寄存器，配置寄存器
- 多线程/中断共享的只读数据。如全局配置
- 固件/ROM数据，可能被外部更新

# knowledge     

## 强制类型转换

- 许多情况下C会自动进行隐式转换，不需要显式强制转换
- 将浮点数转换为整数时会丢弃小数部分
- 将较大类型转换为较小类型可能导致数据截断

## 不同指针的区别
### 整型指针和字符指针的区别

在C语言中，整型指针(`int*`)和字符指针(`char*`)虽然都是指针类型，但在多个方面有重要区别：

#### 1. 指向的数据类型不同

- **整型指针(int*)**：指向整型数据(`int`类型)
- **字符指针(char*)**：指向字符数据(`char`类型)

#### 2. 解引用时的行为不同

```c
int num = 0x12345678;
int *int_ptr = &num;
char *char_ptr = (char *)&num;

printf("%x\n", *int_ptr);  // 输出整个int值: 0x12345678
printf("%x\n", *char_ptr); // 只输出第一个字节(依赖字节序)
```

#### 3. 指针算术运算的步长不同

- `int*`指针加1时，地址增加`sizeof(int)`(通常4字节)
- `char*`指针加1时，地址增加`sizeof(char)`(总是1字节)

```c
int arr[3] = {1, 2, 3};
int *int_p = arr;
char *char_p = (char *)arr;

int_p++;  // 地址增加4字节(指向arr[1])
char_p++; // 地址增加1字节(指向第二个字节)
```

#### 4. 内存访问粒度不同

- `int*`通常按4字节(32位系统)或8字节(64位系统)访问内存
- `char*`按单字节访问内存

#### 5. 常见用途不同

- **int***：
  - 用于操作整型数组
  - 数值计算
  - 作为通用指针(在某些情况下)

- **char***：
  - 字符串处理
  - 内存操作(因为可以逐字节访问)
  - 二进制数据处理

#### 6. 字节序影响

字符指针常用于检测系统字节序：

```c
int num = 0x12345678;
char *p = (char *)#

if (*p == 0x78) {
    printf("小端序\n");
} else {
    printf("大端序\n");
}
```

#### 7. 对齐要求不同

- `int*`通常有更严格的内存对齐要求
- `char*`可以指向任何内存地址

#### 重要注意事项

1. **类型转换需谨慎**：整型指针和字符指针间的转换可能违反严格别名规则
2. **指针运算**：不同类型的指针运算结果完全不同
3. **可移植性**：依赖于系统的字节序和整数大小

理解这些区别对于正确操作内存、避免未定义行为非常重要。



# code




# 跳转链接
[点这里跳转list](../list.md)