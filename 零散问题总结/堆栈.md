# 数据结构
## 堆
- 树形数据结构（完全二叉树）
- 堆排序        
- 最大堆 根节点是整个树最大的元素
- 最小堆 根节点是整个树最小的元素   


## 栈
- 线性数据结构  
- 后进先出
- 只能在栈顶操作
- push pop peek
- 用数组或者链表实现        


### 堆排序
#### 原理
分为大顶堆和小顶堆：    
- 大顶堆:每个节点的值都大于或等于其子节点的值，升序排列
- 小顶堆:每个节点的值都小于或等于其子节点的值，降序排列
步骤：
- 创建一个堆
- 把堆首（最大值）和堆尾互换
- 把堆的尺寸缩小1，并把新的数组顶端数据调整到相应的位置
- 重复上面步骤，知道堆的尺寸为1

#### 实现
```cpp
void myheapsort_low(vector<int>& arr,int size,int index)
{
    int largest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;

    if(left < size && arr[left] > arr[largest])
    {
        largest = left;
    }
    if(right < size && arr[right] > arr[largest])
    {
        largest = right;
    }
    if(largest != index)
    {
    swap(arr[index], arr[largest]);
    myheapsort_low(arr,size,largest);
    }

}
void myheapsort_low_build(vector<int>& arr,int index)
{
    int size = arr.size();
    if(index >= size)
    {
        return;
    }
    int left = 2 * index + 1;
    int right = 2 * index + 2; 
    if(left < size)
    {
        myheapsort_low_build(arr,left);
    }
    if(right < size)
    {
        myheapsort_low_build(arr,right);
    }
    myheapsort_low(arr,size,index);
}

```
#### 时间复杂度
- 构建最大堆O(n)
- 每次调整堆O(logn),需要调整n-1次
- 总时间复杂度O(nlogn)
#### 空间复杂度
O(1) 原地排序，不需要额外存储空间


# 内存管理
## 堆 heap
手动由程序员管理分配            
分配移动较慢        
动态        
可以分配较大空间    
链表式结构  
用于存储动态数据        

会导致：    
内存泄漏        
野指针  
内存碎片化      





## 栈 stack
由编译器管理        
分配移动速度快  
分配空间较小        
栈式数据结构，后进先出 LIFO 
用于存储函数上下文      
会栈溢出（因为递归太深，或过大局部变量）    

## 函数调用的过程
函数A调用函数B
1. 暂停A的执行
2. 保存A的当前状态到内存中-调用栈（压入栈顶）
3. 为B分配栈空间
4. CPU控制权转移到B
5. B执行完毕（return）
6. 销毁B的栈帧
7.  从栈中恢复A的状态
8.  调回A中当初调用B之后的位置开始执行




# java

自动内存管理：  

虚拟机栈：  
每个线程会在创建的时候分配一个私有的栈      

堆：    
JVM中最大的一块内存区域，被所有线程所共享       

垃圾回收管理器，所以程序员不用考虑释放空间      
  
